\section{مقدمه}
\subsection{برنامه‌ها}
در این پروژه می‌خواهیم که تاثیر
\lr{TLB shootdown}
بر روی انواع دیتابیس‌ها را مشاهده کنیم. دیتابیس‌هایی که ما انتخاب کردیم به شرح زیر هستند:
\begin{itemize}
	\item \lr{Redis}
	\item \lr{MySQL}
	\item \lr{Postgres}
	\item \lr{SQLite3}
	\item \lr{CockroachDB}
	\item \lr{Cassandra}
\end{itemize}
همچنین قرار است که در ادامه کمی نیز بر روی نرم‌افزار
\lr{nginx}
کار کنیم چرا که آن نیز در برخی از مواقع
\lr{bottleneck}
وب سرور‌ها است. همچنین در صورتی که بتوانیم می‌خواهیم که از
\lr{syscall}های
\link{https://en.wikipedia.org/wiki/Io_uring}{io\_uring}
برای تست نیز استفاده کنیم. یک
\lr{patch}
(\link{https://github.com/hakasenyang/openssl-patch/issues/21}{لینک})
برای کتابخانه‌های
\lr{nginx}
وجود دارد که به کمک آن می‌توانیم از توابع جدید
\lr{io\_uring}
که برای
\lr{async io}
نوشته شده‌اند استفاده کنیم. به کمک این توابع می‌توانیم عملکرد آن‌ها را با
\link{https://en.wikipedia.org/wiki/Epoll}{epoll}
مقایسه کنیم.

این آزمایش را در چندین محیط و نسخه‌ی کرنل انجام می‌دهیم.
\subsection{محیط‌ metal bare}
در این محیط صرفا ما صرفا بر روی لپتاپ‌های خود یک سیستم‌عامل
\lr{Ubuntu 20.04.6}
را بالا آوردیم و در آن برنامه‌های ذکر شده و کرنل‌های لینوکس را نصب کردیم. مشخصات دستگاه‌های هر یک از ما به شرح
زیر است:

\smalltitle{هیربد:}
\begin{latin}
\begin{itemize}
	\item Intel® Core™ i7-9750H Processor
	\item 16GB DDR3 RAM
	\item OS installed on HDD. 150 GB space.
	\item GTX 1650 Ti
	\item KVM virtualization enabled
\end{itemize}
\end{latin}
\smalltitle{هومان:}
\begin{latin}
\begin{itemize}
	\item TODO
\end{itemize}
\end{latin}

\subsection{محیط‌ virtual}
TODO

\subsection{کامپایل کرنل}
در این آزمایش ما تصمیم گرفتیم که کرنل‌های
\lr{3.19.8}، \lr{4.19.284} و \lr{6.3.6}
استفاده کنیم. همچنین برای ورژن 5 از هر چیزی که بر روی سیستم بای دیفالت نصب بود استفاده می‌کردیم.
به عنوان مثال در نسخه‌ی
\lr{bare metal}
که در
\lr{Ubuntu desktop}
نصب شده است، از ورژن کرنل
\lr{5.15.73}
استفاده می‌کردیم و در ماشین‌های مجازی که از
\lr{Ubuntu server}
استفاده می‌کردند از نسخه‌های
\lr{5.4.150}
استفاده می‌کردیم.

برای شروع در ابتدا به کمک دستور زیر برنامه‌های مورد نیاز را دانلود می‌کنیم:
\codebox{apt install build-essential dwarves python3 libncurses-dev flex bison libssl-dev bc libelf-dev zstd gnupg2 wget curl git}
سپس سورس‌کد‌های لینوکس را از سایت
\link{https://kernel.org/}{kernel.org}
دانلود می‌کنیم و از حالت فشرده خارج می‌کنیم.

سپس باید کانفیگ کرنل را بسازیم. برای
\lr{safe}
بودن از خود کانفیگی که برای سیستم‌عامل فعلی است استفاده می‌کنیم. برای این کار صرفا از کامند زیر
استفاده می‌کنیم:
\codebox{cp /boot/config-\$(uname -r) .config}
این دستور کانفیگی که کرنل فعلی سیستم‌عامل با آن کامپایل شده است را به عنوان کانفیگی که ما می‌خواهیم
کرنل با آن کامپایل شود قرار می‌دهد.

سپس دستور
\lr{make menuconfig}
را می‌زنیم. این دستور یک منو برای کانفیگ کردن کرنل را به ما نشان می‌دهد. اما کار مهم تری که می‌کند این است که
سعی می‌کند که مشکلات فایل کانفیگی که داشتیم را برطرف بکند؛ دقت کنید که از آنجا که نسخه‌ی کرنلی که می‌خواهیم
کامپایل کنیم با نسخه‌ی کرنل سیستم‌عامل خیلی فرق دارد برای همین یک سری تنظیمات وجود دارد که در کانفیگ فایل نیست
یا برعکس. این دستور علاوه بر نشان دادن همه‌ی تنظیمات سعی می‌کند که مقادیر دیفالت قابل قبولی برای
این کانفیگ قرار دهد.

در نهایت به کمک دستور
\codeword{make -j 12}
می‌توان کرنل را کامپایل کرد که 12 تعداد هسته‌های
\lr{CPU}
است. بعد از کامپایل شدن به کمک دستور
\codeword{make modules\_install}
ماژول‌هایی که کامپایل شده است را نصب می‌کنیم و سپس در نهایت به کمک
\codeword{make install}
کرنل را به
\lr{GRUB}
اضافه می‌کنیم که بتوانیم آنرا
\lr{boot}
کنیم.

یکی از مشکلاتی که معمولا در کامپایل لینوکس پیش می‌آید یک
\lr{key chain}
برای امضا کردن ماژول‌هاست. برای اینکه به مشکلی سر کامپایل کردن بر نخوریم، صرفا کافی است که فایل
\codeword{.config}
را با یک
\lr{text editor}
باز کنیم و آپشن‌هایی که فایلی دارند که پسوند آن
\codeword{.pem}
است را حذف کنیم. من حدس میزنم که این ماژول‌ها با یک
\lr{private key}
مخصوص خود
\lr{Ubuntu sign}
شده‌اند که مشخصا در کامپیوتر ما موجود نیست.

هر یک از نسخه‌های کرنل قلقی برای راه اندازی خودشان داشتند که هر کدام از آن‌ها را در اینجا
ذکر می‌کنیم.

\smalltitle{\lr{3.19.8}}
\\\noindent
مشکلی که این نسخه‌ی کرنل داشت این بود که فوق العاده قدیمی هست و برای همین آخرین نسخه‌ی
\lr{GCC}
نمی‌تواند آنرا کامپایل کند! به همین جهت یک ایده‌ای که به ذهنم رسید این بود که لینوکس را در داکر
کامپایل کنم. به همین جهت داکر را نصب کردم و یک ایمیج نسخه‌ی
\lr{14.04}
بالا آوردم و در این کانتینر دقیقا همان کار‌های بالا را انجام دادم با این تفاوت که فایل
\codeword{.config}
را از
\lr{host}
به کانتینر آوردم و صرفا
\codeword{make}
زدم. سپس کل فولدری که در آن کامپایل را انجام دادم را به
\lr{host}
منتقل کردم و در
\lr{host}
دستورات نصب را زدم. با این کار این ورژن به درستی نصب شد ولی مشکلی که وجود داشت این بود که
بعد از بالا آمدن لپتاپ با این ورژن موس پد کار نمی‌کرد! این مشکل خیلی حادی نبود و صرفا یک موس
\lr{USB}
دار کار می‌کرد. از آنجا که این مشکل خیلی حادی نبود از آن چشم پوشی کردم. اما یک مشکل اساسی‌تر رخ داد؛
داکر به صورت کلی از کار افتاد! یعنی سرویس
\lr{dockerd}
دیگر استارت نمی‌شد. پس نمی‌توانستیم دیتابیس‌ها از داکر نصب کنیم بر روی این نسخه‌ی کرنل\dots

\smalltitle{\lr{4.19.284}}
\\\noindent
این نسخه خیلی چالش خاصی نداشت و صرفا توانستیم آنرا با زدن دستورات بالا نصب کرد.

\smalltitle{\lr{6.3.6}}
\\\noindent
کرنل نسخه‌ی 6 هم خیلی مشکلی نداشت صرفا با توجه به
\link{https://techviewleo.com/install-linux-kernel-6-on-ubuntu/}{این}
لینک باید دستور زیر را نیز اجرا می‌کردیم که کلید‌های امضا را غیر فعال کند:
\codebox{scripts/config --disable SYSTEM\_REVOCATION\_KEYS}

\smalltitle{\lr{Host To VM}}
\\\noindent
یکی دیگر از کار‌هایی که سعی کردیم بکنیم این بود که این نسخه‌های کامپایل شده‌ی کرنل را از محیط
\lr{bare metal}
به محیط مجازی ببریم. ولی متاسفانه نتوانستیم این کار را انجام دهیم. مشکلی که وجود داشت این بود که بعد از
دستورات نصب ماژول‌ها و نصب خود کرنل سیستم‌عامل به خاطر پیدا نکردن پارتیشن خودش بالا نمی‌آمد. با کمی سرچ به
\link{https://www.reddit.com/r/linuxquestions/comments/11xjdju/emergency_shell_after_update/}{این}
و
\link{https://askubuntu.com/q/15515/746382}{این}
سوال نیز رسیدیم ولی نتواسنیتم آنرا درست کنیم. نسخه‌ی قبلی کرنل به درستی لود می‌شد ولی نسخه‌ی جدید خیر.
این موضوع را هم با ورژن 3 و هم با ورژن 6 تست کردیم و در همه‌ی حالات به مشکل خوردیم. پس سعی کردیم که کرنل
را خودمان کامپایل کنیم.

\smalltitle{\lr{Perf}}
\\\noindent
یک موضوعی که باید به آن توجه کرد
\lr{perf}
است.
\lr{perf}
در هر نسخه‌ی لینوکس با نسخه‌ی دیگر متفاوت است. پس در نتیجه برای هر نسخه‌ی کرنلی که ما می‌خواهیم از آن استفاده
کنیم می‌بایستی
\lr{perf}
را نیز کامپایل کنیم. خوشبختانه
\lr{perf}
در کنار کرنل لینوکس قرار دارد و نصب آن ساده است. ما از
\link{https://scicoding.com/how-to-compile-perf-with-all-features-on/}{این}
راهنما استفاده کردیم و صرفا لازم بود که چیزی که داخل
\lr{tools/perf}
بود را
\codeword{make}
کنیم. با این کار فایل اجرایی
\lr{perf}
در همان پوشه ساخته می‌شد.

\smalltitle{\lr{Perf in VM}}
\\\noindent
یکی از مشکلاتی که می‌تواند به وجود آید این است در ماشین‌های مجازی
\lr{perf}
تمامی
\lr{event}ها را
\lr{<not supported>}
نشان دهد. این موضوع به دلیل تنظیمات
\lr{CPU KVM}
است. برای درست شدن آن کافی است مانند 
\link{https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_tuning_and_optimization_guide/sect-virtualization_tuning_optimization_guide-monitoring_tools-vpmu}{این}
دستور العمل،‌ عمل کنیم. بدین منظور که دستور ادیت تنظیمات
\lr{VM}
را بزنیم و سپس خط مربوط به
\lr{CPU}
را به خط زیر تغییر دهیم:
\codebox{<cpu mode='host-passthrough'/>}
سپس با ری استارت کردن
\lr{VM}
مشکلات حل می‌شود.