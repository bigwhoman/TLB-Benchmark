\subsection{مقدمه}
\lr{SQLite}
برخلاف
\lr{MySQL} و \lr{PostgreSQL}
نیازی به نصب ندارد و یک
\lr{embedded database}
حساب می‌شود. چرا که صرفا با اضافه کردن
\link{https://www.sqlite.org/download.html}{3 فایل}
به یک پروژه‌ی C می‌توان از آن استفاده کرد.
ما از نسخه‌ای که استفاده کردیم را در فولدر
\lr{sqlite-benchmark}
قرار دادیم.

برای بنچمارک کردن
\lr{SQLite}
ما از برنامه‌ی خاصی استفاده نکردیم. بلکه خودمان یک
\lr{benchmark suite}
برای
\lr{SQLite}
نوشتیم. سورس کد این پروژه در فولدر
\lr{sqlite-benchmark}
موجود است.

\subsubsection{Program Benchmark}
در این قسمت شرح می‌دهیم که برنامه‌ای که نوشتیم چه طور
\lr{SQLite}
را مورد تست و بررسی قرار می‌دهد. این برنامه 5 آرگومان می‌گیرد. اولین ارگومان تعداد
\lr{thread}هایی
است که در زمان
\lr{benchmark}
تنها در حال خواندن از دیتابیس هستند، آرگومان دوم تعداد ترد‌هایی که فقط در حال
نوشتن در دیتابیس هستند و آرگومان سوم تعداد ترد‌هایی که هم می‌‌خوانند و می‌نویسند هست.
آرگومان چهارم تعداد سطر‌هایی است که در جدول
\lr{users}
قرار می‌گیرند. همچنین آخرین آرگومان نیز زمان به ثانیه است.

در ابتدا برنامه وقتی که بالا می‌آید، یک دیتابیس را به صورت کامل با توجه به چهارمین آرگومان بالا می‌آورد که
دیتا‌های رندوم داخل آن است. این دیتابیس عملا یک دیتابیس الکی از یک پایگاه داده سایت
خرید و فروش اجسام مثل دیجیکالا است (اما بسیار ساده‌تر!). دیتابیس حاصل از فرایند
\lr{mock}
شامل 3 جدول است. این سه جدول به شرح زیر هستند:

\smalltitle{users}:
این جدول حاوی اطلاعات افراد است که از ستون‌های زیر تشکیل شده است:
\begin{itemize}
    \item \textbf{id}: یک id که \lr{primary key} این جدول است و به صورت صعودی یکی یکی زیاد می‌شود.
    \item \textbf{first\_name}: بیانگر اسم کوچک فرد
    \item \textbf{last\_name}: بیانگر فامیلی فرد
    \item \textbf{address}: محل سکونت فرد
    \item \textbf{age}: سن شخص به سال و به صورت عدد صحیح
    \item \textbf{coordinates}: مختصات جغرافیایی آدرس شخص به صورت عدد اعشاری و \lr{nullable}
\end{itemize}
\smalltitle{goods}:
این جدول حاوی اجناسی است که در فروشگاه فروخته می‌شوند. همچنین یک
\lr{index}
بر روی ستون
\lr{available}
می‌اندازیم.
\begin{itemize}
    \item \textbf{id}: یک id که \lr{primary key} این جدول است و به صورت صعودی یکی یکی زیاد می‌شود.
    \item \textbf{name}: اسم جنس فروخته شده
    \item \textbf{price}: قیمت جنس به صورت یک عدد صحیح
    \item \textbf{available}: آیا این کالا موجودی دارد یا خیر؟ به صورت یک عدد 1 یا 0 نشان داده می شود.
\end{itemize}
\smalltitle{orders}:
این یک
\lr{pivot table}
برای دو جدول
\lr{users} و \lr{goods}
است. همچنین این جدول
\lr{primary key}
ندارد و صرفا بر اساس
\lr{row id}
که یک متغیر
\lr{intenral} در \lr{SQLite}
است اندیس گذاری می‌شوند. همچنین هر کدام از
\lr{user\_id} و \lr{good\_id}
یک
\lr{forien key}
به جدول‌های خود هستند. دلیل اینکه از
\lr{composite primay key}
استفاده نکردیم این بود که یک شخص می‌تواند چندین سفارش بر روی یک محصول داشته باشد.
\begin{itemize}
    \item \textbf{user\_id}: کلید خارجی به کلید اصلی جدول users
    \item \textbf{good\_id}: کلید خارجی به کلید اصلی جدول goods
    \item \textbf{order\_date}: زمان ثبت سفارش
    \item \textbf{delivery\_time}: زمان تحویل سفارش. در صورتی که سفارش هنوز تحویل داده نشده بود این مقدار \lr{null} است.
\end{itemize}
